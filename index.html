<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <meta name="theme-color" content="#000000" />
        <title>CODE IN THE DARK</title>
        <link rel="preconnect" href="https://fonts.googleapis.com" />
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
        <link
            href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap"
            rel="stylesheet"
        />
        <style>
            :root {
                --bg: #000;
                --cyan: #7ff6ff;
                --x: 50%;
                --y: 50%;
                --beam-r: 120px;
                --beam-r-large: 220px;
                --glow:
                    0 0 6px var(--cyan), 0 0 12px var(--cyan),
                    0 0 24px rgba(127, 246, 255, 0.7);
                --scanline-color: rgba(255, 255, 255, 0.04);
                --vignette: radial-gradient(
                    80% 80% at 50% 50%,
                    rgba(0, 0, 0, 0) 40%,
                    rgba(0, 0, 0, 0.5) 70%,
                    rgba(0, 0, 0, 0.9) 100%
                );
                --crt-on: 0;
                --noise-amt: 0.15;
                --contrast: 1;
                --sweep-y: 50%;
                --reduced-motion: 0;
            }

            @media (prefers-reduced-motion: reduce) {
                :root {
                    --reduced-motion: 1;
                }
            }

            html,
            body {
                margin: 0;
                height: 100%;
                background: var(--bg);
                color: var(--cyan);
                font-family:
                    "Press Start 2P",
                    system-ui,
                    -apple-system,
                    Segoe UI,
                    Roboto,
                    Ubuntu,
                    Cantarell,
                    Noto Sans,
                    "Helvetica Neue",
                    Arial,
                    "Apple Color Emoji",
                    "Segoe UI Emoji",
                    monospace;
                overflow: hidden;
            }

            /* Scene root */
            main#scene {
                position: relative;
                width: 100%;
                height: 100%;
                display: grid;
                place-items: center;
                background: #000;
                filter: contrast(var(--contrast));
            }

            /* Darkness overlay with flashlight hole */
            .darkness {
                position: absolute;
                inset: 0;
                pointer-events: none;
                /* radial transparency at beam center */
                background: radial-gradient(
                    circle at var(--x) var(--y),
                    rgba(0, 0, 0, 0) 0,
                    rgba(0, 0, 0, 0) calc(var(--beam-r) - 20px),
                    rgba(0, 0, 0, 0.35) var(--beam-r),
                    rgba(0, 0, 0, 0.85) calc(var(--beam-r) + 80px),
                    #000 90%
                );
                transition: background 120ms linear;
            }

            /* Idle auto sweep adds subtle moving beam even without input */
            .darkness.idle:not(.static) {
                animation: sweep 6s ease-in-out infinite;
            }
            @keyframes sweep {
                0%,
                100% {
                    --x: 20%;
                    --y: 40%;
                }
                50% {
                    --x: 80%;
                    --y: 60%;
                }
            }

            /* Global overlays: scanlines, noise, vignette */
            .overlays::before,
            .overlays::after {
                content: "";
                position: absolute;
                inset: 0;
                pointer-events: none;
                z-index: 2;
            }
            /* Scanlines */
            .overlays::before {
                background: repeating-linear-gradient(
                    to bottom,
                    rgba(255, 255, 255, 0.06),
                    rgba(255, 255, 255, 0.06) 1px,
                    rgba(0, 0, 0, 0) 2px,
                    rgba(0, 0, 0, 0) 4px
                );
                opacity: calc(0.35 + 0.4 * var(--crt-on));
                mix-blend-mode: overlay;
                animation: scan-flicker 1.8s steps(2, end) infinite;
            }
            @keyframes scan-flicker {
                0%,
                100% {
                    opacity: 0.25;
                }
                50% {
                    opacity: 0.35;
                }
            }
            /* Vignette and subtle noise */
            .overlays::after {
                background: var(--vignette);
                box-shadow: inset 0 0 120px rgba(0, 0, 0, 0.8);
            }

            /* CRT container */
            .crt {
                position: relative;
                width: min(90vw, 900px);
                aspect-ratio: 16/9;
                border-radius: 18px;
                background: radial-gradient(
                    120% 140% at 50% 50%,
                    #001014 0%,
                    #000 70%
                );
                box-shadow:
                    0 0 0 6px #020607,
                    0 0 0 12px #04090b,
                    0 0 42px rgba(127, 246, 255, 0.2);
                overflow: hidden;
                transform: perspective(800px) rotateX(0deg) scale(1);
                transition:
                    transform 400ms ease,
                    filter 400ms ease;
            }
            .crt.powered {
                filter: drop-shadow(0 0 18px rgba(127, 246, 255, 0.25));
                animation: power-seq 1.8s ease both;
            }
            /* Power on sequence */
            @keyframes power-seq {
                0% {
                    filter: brightness(0);
                    transform: perspective(800px) scale(1.04) rotateX(2deg);
                }
                10% {
                    filter: brightness(2.2) contrast(1.4);
                }
                20% {
                    filter: brightness(0.9) contrast(1.1);
                }
                35% {
                    filter: brightness(1.1) contrast(1.2);
                }
                55% {
                    box-shadow:
                        0 0 0 6px #020607,
                        0 0 0 12px #04090b,
                        0 0 82px rgba(127, 246, 255, 0.35);
                }
                100% {
                    transform: perspective(800px) rotateX(0deg) scale(1);
                }
            }

            /* Phosphor screen */
            .screen {
                position: absolute;
                inset: 10px;
                border-radius: 10px;
                background: #000;
                overflow: hidden;
                box-shadow:
                    inset 0 0 30px rgba(127, 246, 255, 0.12),
                    inset 0 0 120px rgba(127, 246, 255, 0.08);
            }
            .screen::before {
                /* moving scan sweep during power-on */
                content: "";
                position: absolute;
                inset: 0;
                background: linear-gradient(
                    to bottom,
                    rgba(127, 246, 255, 0) 0%,
                    rgba(127, 246, 255, 0.15) 50%,
                    rgba(127, 246, 255, 0) 100%
                );
                transform: translateY(-100%);
                opacity: calc(0.2 * var(--crt-on));
                animation: sweep-down 1.6s ease-out both;
                animation-play-state: paused;
            }
            .powered .screen::before {
                animation-play-state: running;
            }
            @keyframes sweep-down {
                0% {
                    transform: translateY(-100%);
                }
                100% {
                    transform: translateY(100%);
                }
            }

            /* Content area */
            .content {
                position: absolute;
                inset: 0;
                display: grid;
                place-items: center;
                padding: 2rem;
                text-align: center;
            }
            .title {
                font-size: clamp(14px, 2.2vw, 20px);
                color: var(--cyan);
                text-shadow: var(--glow);
                letter-spacing: 1px;
                opacity: 0;
                transition: opacity 600ms ease;
            }
            .powered .title {
                opacity: 1;
            }

            /* Blinking caret */
            .caret {
                display: inline-block;
                width: 1ch;
                color: var(--cyan);
            }
            .caret.blink {
                animation: blink 1s steps(1, end) infinite;
            }
            @keyframes blink {
                0%,
                50% {
                    opacity: 1;
                }
                51%,
                100% {
                    opacity: 0;
                }
            }

            /* Controls */
            .controls {
                position: absolute;
                bottom: 10px;
                left: 10px;
                display: flex;
                gap: 8px;
                z-index: 3;
            }
            button.ctrl {
                background: rgba(2, 20, 24, 0.6);
                color: var(--cyan);
                border: 1px solid rgba(127, 246, 255, 0.35);
                padding: 8px 10px;
                font: inherit;
                font-size: 10px;
                letter-spacing: 0.5px;
                border-radius: 6px;
                text-shadow: 0 0 6px rgba(127, 246, 255, 0.5);
                cursor: pointer;
            }
            button.ctrl:focus {
                outline: 2px solid var(--cyan);
                outline-offset: 1px;
            }

            /* Power button overlay (find via flashlight) */
            .power-btn {
                position: absolute;
                right: 18px;
                bottom: 18px;
                width: 42px;
                height: 42px;
                border-radius: 50%;
                background: radial-gradient(
                    circle at 35% 35%,
                    rgba(127, 246, 255, 0.25),
                    rgba(2, 20, 24, 0.6)
                );
                border: 2px solid rgba(127, 246, 255, 0.5);
                color: var(--cyan);
                display: grid;
                place-items: center;
                cursor: pointer;
                z-index: 4;
                box-shadow: 0 0 10px rgba(127, 246, 255, 0.3);
            }
            .power-btn:focus {
                outline: 3px solid var(--cyan);
            }

            /* Glitch flash effect */
            .glitch {
                filter: contrast(1.7) saturate(1.2) hue-rotate(-5deg);
            }

            /* Static mode shows everything, disables animations */
            .static .darkness {
                background: transparent;
            }
            .static .darkness.idle {
                animation: none;
            }
            .static .overlays::before {
                opacity: 0.2;
                animation: none;
            }
            .static .crt {
                animation: none;
            }

            /* Reduced motion adjustments */
            @media (prefers-reduced-motion: reduce) {
                .darkness.idle {
                    animation: none !important;
                }
                .overlays::before {
                    animation: none !important;
                }
                .screen::before {
                    animation: none !important;
                }
            }
        </style>
    </head>
    <body>
        <main
            id="scene"
            class="overlays"
            aria-label="Interactive flashlight scene with CRT monitor"
        >
            <div class="crt" id="crt">
                <div class="screen">
                    <div class="content">
                        <div id="typewriter" aria-hidden="false"></div>
                        <span id="caret" class="caret" aria-hidden="true"
                            >▌</span
                        >
                        <!-- ARIA live region updated after typing completes -->
                        <div
                            id="live"
                            role="status"
                            aria-live="polite"
                            aria-atomic="true"
                            style="
                                position: absolute;
                                width: 1px;
                                height: 1px;
                                overflow: hidden;
                                clip: rect(0 0 0 0);
                                white-space: nowrap;
                            "
                        ></div>
                    </div>
                </div>
                <button
                    id="power"
                    class="power-btn"
                    aria-label="Power on CRT"
                    aria-pressed="false"
                ></button>
            </div>

            <div class="controls" aria-label="Controls">
                <button
                    class="ctrl"
                    id="toggle-sound"
                    aria-pressed="false"
                    aria-label="Toggle sound"
                >
                    Sound: Off
                </button>
                <button
                    class="ctrl"
                    id="toggle-static"
                    aria-pressed="false"
                    aria-label="Toggle static mode"
                >
                    Static: Off
                </button>
                <button class="ctrl" id="reset" aria-label="Reset scene">
                    Reset
                </button>
            </div>

            <div class="darkness idle" id="darkness"></div>
        </main>

        <script>
            // State
            const state = {
                x: 50,
                y: 50,
                r: 120,
                large: false,
                powered: false,
                typing: false,
                soundOn: false,
                staticMode: false,
                reduced: window.matchMedia("(prefers-reduced-motion: reduce)")
                    .matches,
                lastMoveTs: performance.now(),
                lastTapTs: 0,
                raf: null,
                sweepRAF: null,
            };

            // Elements
            const root = document.documentElement;
            const scene = document.getElementById("scene");
            const darkness = document.getElementById("darkness");
            const crt = document.getElementById("crt");
            const powerBtn = document.getElementById("power");
            const tw = document.getElementById("typewriter");
            const caret = document.getElementById("caret");
            const live = document.getElementById("live");
            const toggleSound = document.getElementById("toggle-sound");
            const toggleStatic = document.getElementById("toggle-static");
            const resetBtn = document.getElementById("reset");

            // Utility: set CSS vars
            function setBeam(x, y, r = state.r) {
                root.style.setProperty("--x", x + "%");
                root.style.setProperty("--y", y + "%");
                root.style.setProperty("--beam-r", r + "px");
            }
            setBeam(state.x, state.y, state.r);

            // Pointer handling with rAF throttle
            let pendingMove = null;
            function onPointerMove(e) {
                state.lastMoveTs = performance.now();
                const rect = scene.getBoundingClientRect();
                const cx = ((e.clientX - rect.left) / rect.width) * 100;
                const cy = ((e.clientY - rect.top) / rect.height) * 100;
                pendingMove = {
                    x: Math.min(100, Math.max(0, cx)),
                    y: Math.min(100, Math.max(0, cy)),
                };
                if (!state.raf) state.raf = requestAnimationFrame(applyMove);
            }
            function applyMove() {
                if (pendingMove) {
                    state.x = pendingMove.x;
                    state.y = pendingMove.y;
                    pendingMove = null;
                    setBeam(state.x, state.y, state.large ? 220 : 120);
                }
                state.raf = null;
            }

            // Idle sweep
            function startIdleSweep() {
                if (state.reduced || state.staticMode) return;
                darkness.classList.add("idle");
            }
            function stopIdleSweep() {
                darkness.classList.remove("idle");
            }

            // Long-press to enlarge beam
            let longPressTimer = null;
            function onPointerDown(e) {
                // Gesture unlock for audio
                if (audio.ctx.state === "suspended") {
                    audio.ctx.resume().catch(() => {});
                }
                // Double-tap detection
                const now = performance.now();
                if (now - state.lastTapTs < 300) {
                    playGlitch();
                    vibrate(40);
                    crt.classList.add("glitch");
                    setTimeout(() => crt.classList.remove("glitch"), 150);
                }
                state.lastTapTs = now;
                clearTimeout(longPressTimer);
                longPressTimer = setTimeout(() => {
                    state.large = true;
                    setBeam(state.x, state.y, 220);
                    // more static intensity while pressed
                    root.style.setProperty("--contrast", "1.15");
                }, 400);
            }
            function onPointerUp() {
                clearTimeout(longPressTimer);
                state.large = false;
                setBeam(state.x, state.y, 120);
                root.style.setProperty("--contrast", "1");
            }

            // Visibility handling
            document.addEventListener("visibilitychange", () => {
                if (document.hidden) {
                    audio.pauseAll();
                } else if (state.soundOn && state.powered) {
                    audio.ambient(true);
                }
            });

            // Audio (WebAudio) --------------------------------------------------------
            const audio = (() => {
                const ctx = new (window.AudioContext ||
                    window.webkitAudioContext)();
                let hissNode = null;
                let glitchNode = null;
                function makeNoiseBuffer(seconds = 2) {
                    const rate = ctx.sampleRate;
                    const len = seconds * rate;
                    const buffer = ctx.createBuffer(1, len, rate);
                    const data = buffer.getChannelData(0);
                    for (let i = 0; i < len; i++)
                        data[i] = Math.random() * 2 - 1;
                    return buffer;
                }
                const noiseBuf = makeNoiseBuffer(2);

                function ambient(on) {
                    if (!on) {
                        if (hissNode) {
                            hissNode.stop();
                            hissNode.disconnect();
                            hissNode = null;
                        }
                        return;
                    }
                    if (hissNode) return;
                    hissNode = ctx.createBufferSource();
                    hissNode.buffer = noiseBuf;
                    hissNode.loop = true;
                    const filter = ctx.createBiquadFilter();
                    filter.type = "bandpass";
                    filter.frequency.value = 8000;
                    filter.Q.value = 0.4;
                    const gain = ctx.createGain();
                    gain.gain.value = 0.05; // subtle
                    hissNode
                        .connect(filter)
                        .connect(gain)
                        .connect(ctx.destination);
                    hissNode.start();
                }
                function glitch() {
                    const src = ctx.createBufferSource();
                    src.buffer = noiseBuf;
                    const gain = ctx.createGain();
                    gain.gain.setValueAtTime(0.0, ctx.currentTime);
                    gain.gain.linearRampToValueAtTime(
                        0.5,
                        ctx.currentTime + 0.02,
                    );
                    gain.gain.exponentialRampToValueAtTime(
                        0.0001,
                        ctx.currentTime + 0.2,
                    );
                    src.connect(gain).connect(ctx.destination);
                    src.start();
                    setTimeout(() => {
                        src.stop();
                        src.disconnect();
                    }, 220);
                }
                function tick() {
                    const osc = ctx.createOscillator();
                    osc.type = "square";
                    osc.frequency.setValueAtTime(1200, ctx.currentTime);
                    const gain = ctx.createGain();
                    gain.gain.setValueAtTime(0.0001, ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(
                        0.08,
                        ctx.currentTime + 0.01,
                    );
                    gain.gain.exponentialRampToValueAtTime(
                        0.0001,
                        ctx.currentTime + 0.06,
                    );
                    osc.connect(gain).connect(ctx.destination);
                    osc.start();
                    osc.stop(ctx.currentTime + 0.08);
                }
                function pauseAll() {
                    ambient(false);
                }
                return { ctx, ambient, glitch, tick, pauseAll };
            })();

            function initAudio() {
                /* API placeholder for TASK spec */
            }
            function playGlitch() {
                if (state.soundOn) audio.glitch();
            }
            function playTick() {
                if (state.soundOn) audio.tick();
            }
            function vibrate(ms) {
                if (navigator.vibrate) navigator.vibrate(ms);
            }

            // Typewriter --------------------------------------------------------------
            const MESSAGE = "CODE IN THE DARK — Stay tuned!";
            let typeIndex = 0;
            let typeTimer = null;
            function startTypewriter() {
                if (state.typing) return;
                state.typing = true;
                typeIndex = 0;
                tw.textContent = "";
                caret.classList.remove("blink");
                const cps = 28 + Math.floor(Math.random() * 8); // 28–36 cps
                const interval = 1000 / cps;
                function step() {
                    if (!state.typing) return; // interrupted
                    if (typeIndex < MESSAGE.length) {
                        tw.textContent += MESSAGE[typeIndex++];
                        playTick();
                        vibrate(8);
                        typeTimer = setTimeout(step, interval);
                    } else {
                        caret.classList.add("blink");
                        state.typing = false;
                        // Announce final text in live region
                        live.textContent = MESSAGE;
                    }
                }
                step();
            }
            function stopTypewriter() {
                state.typing = false;
                clearTimeout(typeTimer);
                tw.textContent = "";
                caret.classList.remove("blink");
                live.textContent = "";
            }

            // Power control -----------------------------------------------------------
            function powerOn() {
                if (state.powered) return;
                state.powered = true;
                root.style.setProperty("--crt-on", "1");
                crt.classList.add("powered");
                // Strong buzz
                vibrate(120);
                if (state.soundOn) audio.ambient(true);
                startTypewriter();
                powerBtn.setAttribute("aria-pressed", "true");
                powerBtn.setAttribute("aria-label", "Power off CRT");
            }
            function powerOff() {
                if (!state.powered) return;
                state.powered = false;
                root.style.setProperty("--crt-on", "0");
                crt.classList.remove("powered");
                audio.ambient(false);
                stopTypewriter();
                powerBtn.setAttribute("aria-pressed", "false");
                powerBtn.setAttribute("aria-label", "Power on CRT");
            }

            function powerToggle() {
                state.powered ? powerOff() : powerOn();
            }

            // Controls ----------------------------------------------------------------
            toggleSound.addEventListener("click", () => {
                state.soundOn = !state.soundOn;
                toggleSound.setAttribute("aria-pressed", String(state.soundOn));
                toggleSound.textContent =
                    "Sound: " + (state.soundOn ? "On" : "Off");
                if (state.soundOn && state.powered) audio.ambient(true);
                else audio.ambient(false);
            });

            toggleStatic.addEventListener("click", () => {
                state.staticMode = !state.staticMode;
                scene.classList.toggle("static", state.staticMode);
                toggleStatic.setAttribute(
                    "aria-pressed",
                    String(state.staticMode),
                );
                toggleStatic.textContent =
                    "Static: " + (state.staticMode ? "On" : "Off");
                if (state.staticMode) stopIdleSweep();
                else startIdleSweep();
            });

            resetBtn.addEventListener("click", () => {
                powerOff();
            });

            // Power button interactions
            powerBtn.addEventListener("click", powerToggle);
            powerBtn.addEventListener("keydown", (e) => {
                if (e.key === "Enter" || e.code === "Space" || e.key === " ") {
                    e.preventDefault();
                    powerToggle();
                }
            });

            // Scene pointer wiring
            scene.addEventListener("pointermove", onPointerMove);
            scene.addEventListener("pointerdown", onPointerDown);
            window.addEventListener("pointerup", onPointerUp);

            // Idle sweep scheduler
            let idleTimer = null;
            function scheduleIdle() {
                clearTimeout(idleTimer);
                stopIdleSweep();
                idleTimer = setTimeout(() => {
                    if (!state.reduced && !state.staticMode) startIdleSweep();
                }, 1500);
            }
            ["pointermove", "pointerdown", "pointerup"].forEach((ev) =>
                scene.addEventListener(ev, scheduleIdle),
            );
            scheduleIdle();

            // Initial ARIA states
            toggleSound.textContent = "Sound: Off";
            toggleSound.setAttribute("aria-pressed", "false");
            toggleStatic.textContent = "Static: Off";
            toggleStatic.setAttribute("aria-pressed", "false");

            // Fallback note: if CSS mask-image desired, uncomment below to switch strategy
            // darkness.style.webkitMaskImage = darkness.style.maskImage = `radial-gradient(circle at var(--x) var(--y), transparent var(--beam-r), black calc(var(--beam-r) + 1px))`;
        </script>
    </body>
</html>
